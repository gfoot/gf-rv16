Some things to do at some point

Priorities:
 * Write more code
 * Accurate instruction-fetch simulation


ISA design

 * Redo the ISA encoding and pin down immediate widths
	I think this is mostly settled now, there are some holes in the encoding space that could be
	filled if the need arises and it would be nice to increase JAL's range but I want to write a
	larger amount of code before making a call on that based on statistics

 * Write a thorough instruction set test suite (hard)
	There are lots of possible inputs to each instruction, too many to test, and important
	edge cases do exist but are hard to identify

 * Make sure SLTI works properly, it might require its immediate to be inverted by the encoder


System software

 * On-device ebreak/callstack handling
	Again the problem is the simulator is doing all the work, which won't work with hardware

 * Flesh out OS and library code


Assembler

 * Should listing files show literal interpretation of encoded instructions, or logical purpose?
	i.e. slli x8,x8,16 or li x8,0?  ori x1,x2,12 or li x1,12?  bne x5,x5,6 or bnez x5,6?
	GNU assembler condenses things to canonical forms and even pseudoinstructions, like my
	disassembler does already, so maybe that's the way to go

 * Should listing files show branches and jumps with absolute or relative addresses?
	pseudotest.s expects relative addresses
	GNU assembler shows absolute addresses along with label names in angle brackets
	If I use absolute addresses it becomes less clear what is actually being encoded
	and pseudotest is less useful overall

 * Should it use the list of PC-relative instructions, or be more dynamic about that?
	I think it needs a list, though it could be generated from encode.py


Simulator/debugging

 * Simulate a hardware timer - MMIO + IRQ

 * Simulate "send" IRQ somehow?

 * Make I/O and timer simulation more like 65C51/65C22

 * Simulate pipelined instruction fetch as part of microcode simulation

 * Simulate IC pins

 * Offline debugger

 * REPL for simulator (single step, breakpoints, etc)

 * Log memory reads and writes in traces

 * tools/stats.py seems to be broken, it's not combining auipc/addi pairs etc


Hardware design

 * Design and validate the instruction fetch/program counter electronics

 * Try embedding control signals in PLDs

 * Finish ALU design


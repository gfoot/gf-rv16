# Thinking about function prologue/epilogue macros
#
# I'll use GNU Assembler's macro syntax - not sure about the altmacro thing though
#
# Some functions don't need any prologue/epilogue
# Some need to save ra but nothing else
# Anything more complex might as well save ra, s0, and s1
# It could be good to store a frame pointer to make a debugger easier to write
#
# In addition, the ability to reserve local variable space relative to sp is useful
# And being able to name any stack-passed parameters above the initial sp is also useful
#
# I could use an "enter" macro that saves ra and optionally s0 and s1, and optionally 
# also reserves more space for local variables
# plus a macro to name the local variables
# and another to name the parameters
#
# The first the arguments are passed in registers
#
#                   arg6
#                   arg5
#   initial sp =>   arg4
#                   ra
#                   s0
#                   s1
#                   local3
#                   local2
#  adjusted sp =>   local1
#
# To achieve this you'd write:
#
#	myfunc:
#		enter	3       # Number of locals
#		local	local1, local2, local3
#		args	arg4, arg5, arg6
#
#		lw		t0, arg4(sp)
#		sw		t0, local2(sp)
#
# etc
#
# enter needs to subtract 6+2*x from sp and set up variables to track the local and 
# argument addresses relative to the new sp
#
# It may be possible for enter to take the local names as its own parameters instead 
# of a number, e.g.:
#
#	myfunc:
#		enter	local1, local2
#		args	arg4, arg5, arg6
#
# It could even take the argument names as well but then it'd be hard to tell the 
# difference between locals an arguments so probably not a good idea
#
# I also like having the option of splitting them across lines for clarity if the 
# names are long:
#
#	myfunc:
#		enter	3
#		local	first_local_variable
#		local	another_local_variable
#		local	save_a0
#		local	save_a1
#		arg		fourth_function_parameter
#		arg		fifth_function_parameter
#
# The leave macro can also be autogenerated.
#
# One point that makes macros like this a bit less useful is the way some arguments
# are passed in registers rather than on the stack, meaning the mechanisms for
# addressing different arguments are going to be different anyway.  So maybe the
# support for naming arguments is not worthwhile.

